---
title: 'Run PC-Relate by block'
author: 'Jai Broome'
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 3
    number_sections: yes
    code_folding: show
---

# Introduction

Because of the computational requirements to run PC-Relate, it may be necessary
to separate your samples into blocks and either run them one-by-one or in
parallel. We demonstrate how to do this here, starting with the KING GRM and
first iteration of PC-AiR generated by the pipeline vignette.

# Setup

## Save start time

This is used to calculate the amount of time needed to render this document.

```{r st}
st <- Sys.time()
```

## R Libraries

```{r library, message = FALSE}
library(magrittr)
library(knitr)
library(dplyr)
library(SeqArray)
library(SeqVarTools)
library(GENESIS)
```

## Knitr chunk options

```{r bash_options}
opts_chunk$set(engine.opts = list(bash = "-l"))
```

Specify that executed code and its output should be in the same chunk. This
allows you to hide long output by clicking the "Hide" button.

```{r collapse}
opts_chunk$set(collapse = TRUE)
```

## Make subdirectories

**bash:**

```{bash}
mkdir tmp pcr_fig pcr_out
# Clean up files from previous times this document may have been rendered
# touch temporary files so script doesn't crash if directories are empty
touch tmp/deleteme pcr_fig/deleteme pcr_out/deleteme
rm tmp/* pcr_fig/* pcr_out/*
```

# PC-Relate, iteration A

## Calculate betas from the unrelated set

Our first step running PC-Relate manually is to calculate individual-specific
allele frequency betas, using PCs from the previous step and unrelated samples.

```{r a-betas}
gds_file <- "vignette_out/example.gds"
gds <- seqOpen(gds_file)
seqData <- SeqVarData(gds)
pruned_snps <- readRDS("vignette_out/pruned_snps.rds")
pca_keep <- readRDS("vignette_out/kinship_errors_rm.rds")
seqSetFilter(seqData, variant.id = pruned_snps)
a_pca <- readRDS("vignette_out/a_pcair.rds")
n_pcs <- 3
a_pcs <- as.matrix(a_pca$vectors[,1:n_pcs])
a_beta_sample_include <- samplesGdsOrder(seqData, a_pca$unrels) %>% intersect(pca_keep)
iterator <- SeqVarBlockIterator(seqData, variantBlock = 2500)
a_beta <- calcISAFBeta(iterator, pcs = a_pcs,
                       sample.include = a_beta_sample_include, verbose = FALSE)
saveRDS(a_beta, "tmp/a_beta.rds")
```

## Run PC-Relate by block

With the AF betas calculated, we can run PC-Relate. We'll cut our samples into
five equal-sized vectors, Then run `pcrelateSampBlock()` on each permutation of
blocks. Note that we don't need to run both, for example, `pcrelateSampBlock()`
with block 1-block 5 and block 5-block 1.

```{r a-pcr}
seqResetFilter(seqData)
seqSetFilter(seqData, variant.id = pruned_snps)
a_pcr_sample_include <- samplesGdsOrder(seqData, rownames(a_pcs)) %>% intersect(pca_keep)
nsampblock <- 5
a_samp_block <- unname(split(a_pcr_sample_include, cut(1:length(a_pcr_sample_include), nsampblock)))
for (i in nsampblock:1){
  for (j in i:nsampblock){
    out <- pcrelateSampBlock(iterator, betaobj = a_beta, pcs = a_pcs,
                             sample.include.block1 = a_samp_block[[i]],
                             sample.include.block2 = a_samp_block[[j]],
                             verbose = FALSE)
    saveRDS(out, file = paste0("tmp/a_pcrelate_block_", i, "_", j, ".rds"))
  }
}
```

## Combine and correct PC-Relate blocks

Lastly, we'll correct K0 and K2 values and combine the blocks.

```{r a-pcr-combine}
a_kinSelf <- NULL
a_kinBtwn <- NULL
# First index is reversed based on the implementation in the TOPMed pipeline.
# It is important to do it in this order so that kinSelf gets loaded in in time.
for (i in nsampblock:1){
  for (j in i:nsampblock){
    res <- paste0("tmp/a_pcrelate_block_", i, "_", j, ".rds") %>% readRDS()
    if(i == j) a_kinSelf %<>% rbind(res$kinSelf)
    res$kinBtwn <- correctK2(kinBtwn = res$kinBtwn, kinSelf = a_kinSelf,
                             small.samp.correct = FALSE, pcs = NULL,
                             sample.include = NULL)
    res$kinBtwn <- correctK0(kinBtwn = res$kinBtwn)
    saveRDS(res, file = paste0("tmp/a_corrected_pcrelate_block_", i, "_", j, ".rds"))
    a_kinBtwn %<>% rbind(res$kinBtwn)
    rm(res)
  }
}
```

Combine the outputs, create the (sparsified) GRM, and write it to disk.

```{r a-pcr-out}
# Sparsification threshold
kin.thresh <- 2 ^ (-11 / 2)
a_pcrelobj <- list(kinSelf = a_kinSelf, kinBtwn = a_kinBtwn)
class(a_pcrelobj) <- "pcrelate"
saveRDS(a_pcrelobj, "tmp/a_pcrelate.rds")
a_pcr_mat <- pcrelateToMatrix(a_pcrelobj, thresh = kin.thresh, scaleKin = 1)
saveRDS(a_pcr_mat, "tmp/a_pcr_mat.rds")
```

# PC-AiR, iteration B

For the second iterations, we proceed as normal. Use both the PC-Relate and
KING GRMs for PC-AiR:

*_bash_*:

```{bash}
pcair.R vignette_out/example.gds \
  tmp/a_pcr_mat.rds \
  vignette_out/king_grm.rds \
  --out_prefix pcr_out/b_ \
  --sample_id vignette_out/kinship_errors_rm.rds \
  --variant_id vignette_out/pruned_snps.rds \
  --num_core 14
```

```{bash}
pca_plots.R pcr_out/b_pcair.rds \
  --out_prefix pcr_fig/b_ #\
#  --phenotype_file /nfs/beluga0_home/ANALYSIS/INTEGRATED/combine-pheno/pheno_combined.rds \
#  --group race_eth_cmbd \
#  --n_pairs 5
```

# PC-Relate, iteration B

## Calculate betas from the unrelated set

```{r b-betas}
seqResetFilter(seqData)
seqSetFilter(seqData, variant.id = pruned_snps)

b_pca <- readRDS("pcr_out/b_pcair.rds")
b_pcs <- as.matrix(b_pca$vectors[,1:n_pcs])
b_beta_sample_include <- samplesGdsOrder(seqData, b_pca$unrels) %>% intersect(pca_keep)
b_beta <- calcISAFBeta(iterator, pcs = b_pcs, sample.include = b_beta_sample_include,
                       verbose = FALSE)
saveRDS(b_beta, "tmp/b_beta.rds")
```

## Run PC-Relate by block

```{r b-pcr}
seqResetFilter(seqData)
seqSetFilter(seqData, variant.id = pruned_snps)
b_pcr_sample_include <- samplesGdsOrder(seqData, rownames(b_pcs)) %>% intersect(pca_keep)
b_samp_blocks <- unname(split(b_pcr_sample_include, cut(1:length(b_pcr_sample_include), nsampblock)))
for (i in nsampblock:1){
  for (j in i:nsampblock){
    out <- pcrelateSampBlock(iterator, betaobj = b_beta, pcs = b_pcs,
                             sample.include.block1 = b_samp_blocks[[i]],
                             sample.include.block2 = b_samp_blocks[[j]],
                             verbose = FALSE)
    saveRDS(out, file = paste0("tmp/b_pcrelate_block_", i, "_", j, ".rds"))
  }
}
```

## Combine and correct PC-Relate blocks

```{r b-pcr-combine}
b_kinSelf <- NULL
b_kinBtwn <- NULL
for (i in nsampblock:1){
  for (j in i:nsampblock){
    res <- paste0("tmp/b_pcrelate_block_", i, "_", j, ".rds") %>% readRDS()
    if(i == j) b_kinSelf %<>% rbind(res$kinSelf)
    res$kinBtwn <- correctK2(kinBtwn = res$kinBtwn, kinSelf = b_kinSelf,
                             small.samp.correct = FALSE, pcs = NULL,
                             sample.include = NULL)
    res$kinBtwn <- correctK0(kinBtwn = res$kinBtwn)
    saveRDS(res, file = paste0("tmp/b_corrected_pcrelate_block_", i, "_", j, ".rds"))
    b_kinBtwn %<>% rbind(res$kinBtwn)
    rm(res)
  }
}
```

```{r b-pcr-out}
b_pcrelobj <- list(kinSelf = b_kinSelf, kinBtwn = b_kinBtwn)
class(b_pcrelobj) <- "pcrelate"
saveRDS(b_pcrelobj, "pcr_out/b_pcrelate.rds")
# Note that we use scaleKin = 2 for iteration B
b_pcr_mat <- pcrelateToMatrix(b_pcrelobj, thresh = kin.thresh, scaleKin = 2)
saveRDS(b_pcr_mat, "pcr_out/b_pcr_mat.rds")
```

```{r seqClose}
seqClose(seqData)
```

# Wrap-up

*_bash_*:

```{bash}
rm -r tmp
```

Elapsed time:

```{r}
Sys.time() - st
```
